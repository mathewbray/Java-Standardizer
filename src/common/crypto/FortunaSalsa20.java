/*====================================================================*\

FortunaSalsa20.java

Fortuna/Salsa20 pseudo-random number generator class.

\*====================================================================*/


// PACKAGE


package common.crypto;

//----------------------------------------------------------------------


// IMPORTS


import java.io.UnsupportedEncodingException;

import common.exception.UnexpectedRuntimeException;

//----------------------------------------------------------------------


// FORTUNA/SALSA20 PSEUDO-RANDOM NUMBER GENERATOR CLASS


/**
 * This class implements the Fortuna pseudo-random number generator (PRNG) algorithm, using a Salsa20 stream
 * cipher as the underlying generator.
 */

public class FortunaSalsa20
	extends Fortuna
	implements Cloneable
{

////////////////////////////////////////////////////////////////////////
//  Constants
////////////////////////////////////////////////////////////////////////

	/**
	 * The size (in bytes) of the PRNG's key, which is the key size of the Salsa20 cipher.
	 */
	public static final		int	KEY_SIZE	= Salsa20.KEY_SIZE;

	private static final	int	NUM_ROUNDS	= 20;

	private static final	String	NONCE_ENCODING_NAME	= "US-ASCII";
	private static final	String	NONCE_STR			= "OFortuna";

////////////////////////////////////////////////////////////////////////
//  Constructors
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a Fortuna/Salsa20 pseudo-random number generator that is initialised with a random seed
	 * derived from the sources of entropy.
	 * <p>
	 * The PRNG will not be able to generate random data until sufficient entropy has accumulated for the
	 * generator to be reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 */

	public FortunaSalsa20()
	{
		this((byte[])null);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/Salsa20 pseudo-random number generator that is initialised with a specified seed.
	 * <p>
	 * If the seed is {@code null}, a random seed derived from the sources of entropy will be used.  In this
	 * case, the PRNG will not be able to generate random data until sufficient entropy has accumulated for
	 * the generator to be reseeded.  The ability to reseed can be tested with {@link #canReseed()}.
	 * </p>
	 *
	 * @param seed  a sequence of bytes that will be used to seed the pseudo-random number generator.  If
	 *              {@code seed} is {@code null}, a random seed derived from the sources of entropy will be
	 *              used.
	 */

	public FortunaSalsa20(byte[] seed)
	{
		// Call superclass constructor
		super(Salsa20.KEY_SIZE, Salsa20.BLOCK_SIZE, seed);
	}

	//------------------------------------------------------------------

	/**
	 * Creates a Fortuna/Salsa20 pseudo-random number generator that is initialised with a specified seed in
	 * the form of a string.
	 *
	 * @param seed  a string whose UTF-8 encoding will be used to seed the pseudo-random number generator.
	 */

	public FortunaSalsa20(String seed)
	{
		this(keyStringToBytes(seed));
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Class methods
////////////////////////////////////////////////////////////////////////


	/**
	 * Creates an object that will combine data and random data generated by a PRNG with an exclusive-OR
	 * operation.
	 * <p>
	 * The PRNG is created by this method and initialised with a specified seed.  If the seed is {@code
	 * null}, a random seed derived from the sources of entropy will be used.  In this case, the PRNG will
	 * not be able to generate random data until sufficient entropy has accumulated for the generator to be
	 * reseeded.  The ability to reseed can be tested with the {@link Fortuna#canReseed() canReseed()}
	 * method of the PRNG that is returned by {@link Fortuna.XorCombiner#getPrng()}.
	 * </p>
	 *
	 * @param  seed       the seed that will be used to initialise the PRNG that will generate the random
	 *                    data for the exclusive-OR operation.  If {@code seed} is {@code null}, a random
	 *                    seed derived from the sources of entropy will be used.
	 * @param  blockSize  the number of bytes of random data that will be extracted from this object's
	 *                    PRNG with each request.
	 * @return an exclusive-OR combiner object.
	 * @throws IllegalArgumentException
	 *           if {@code blockSize} is less than 1 or greater than 2<sup>20</sup> (1048576).
	 */

	public static XorCombiner createCombiner(byte[] seed,
											 int    blockSize)
	{
		return new XorCombiner(new FortunaSalsa20(seed), blockSize);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance methods : overriding methods
////////////////////////////////////////////////////////////////////////

	/**
	 * Creates a copy of this PRNG.
	 * <p>
	 * The copy is initially identical to this object (it has the same state and entropy pools), but the
	 * two objects are independent.
	 * </p>
	 *
	 * @return a copy of this PRNG.
	 */

	@Override
	public FortunaSalsa20 clone()
	{
		FortunaSalsa20 copy = (FortunaSalsa20)super.clone();
		copy.cipher = cipher.clone();
		return copy;
	}

	//------------------------------------------------------------------

	/**
	 * Initialises this PRNG's cipher.
	 */

	protected void initCipher()
	{
		cipher = new Salsa20(NUM_ROUNDS);
	}

	//------------------------------------------------------------------

	/**
	 * Resets this PRNG's cipher.
	 */

	protected void resetCipher()
	{
		cipher.reset();
		counter = 0;
	}

	//------------------------------------------------------------------

	/**
	 * Sets the encryption key of this PRNG's cipher.
	 *
	 * @param key  the key that will be set as the cipher's encryption key.
	 * @throws UnexpectedRuntimeException
	 *           if the US-ASCII character encoding is not supported by the Java implementation.
	 */

	protected void setCipherKey(byte[] key)
	{
		try
		{
			cipher.init(key, NONCE_STR.getBytes(NONCE_ENCODING_NAME));
		}
		catch (UnsupportedEncodingException e)
		{
			throw new UnexpectedRuntimeException(e);
		}
	}

	//------------------------------------------------------------------

	/**
	 * Increments the block counter of this PRNG's cipher.
	 */

	protected void incrementCounter()
	{
		++counter;
	}

	//------------------------------------------------------------------

	/**
	 * Encrypts the value of the block counter with this PRNG's cipher and stores the result in a specified
	 * buffer.
	 *
	 * @param buffer  the buffer in which the encrypted data will be stored.
	 * @param offset  the offset in {@code buffer} at which the first byte of encrypted data will be stored.
	 */

	protected void encryptCounter(byte[] buffer,
								  int    offset)
	{
		cipher.getBlock(counter, buffer, offset);
	}

	//------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////
//  Instance fields
////////////////////////////////////////////////////////////////////////

	private	Salsa20	cipher;
	private	long	counter;

}

//----------------------------------------------------------------------
